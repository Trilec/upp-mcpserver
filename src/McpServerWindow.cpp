/**
 * @file McpServerWindow.cpp
 * @brief GUI window logic for MCP Server.
 */
#include "McpServerWindow.h" // Class definition
#include "../include/McpServer.h"   // For McpServer class
#include "ConfigManager.h"     // For Config struct
#include "McpSplash.h"         // For McpSplash class (assuming McpSplash.h will exist)

McpServerWindow::McpServerWindow(McpServer& server, Config& cfg)
    : server_ref(server), current_config_ref(cfg)
{
    CtrlLayoutOK(*this); // This loads the layout defined in McpServerWindow.h (via .lay)
    Title("MCP Server Control Panel");

    // --- Initialize UI from Config ---
    SyncConfigToUI();

    // --- Wire up event handlers ---
    // Sidebar navigation
    btnMenu.WhenAction = THISBACK(MenuAction); // Example: toggle sidebar width or show menu
    btnToolsIcon.WhenAction = THISBACK(ShowToolsPanel);
    btnConfigIcon.WhenAction = THISBACK(ShowConfigPanel);
    btnPermsIcon.WhenAction = THISBACK(ShowPermsPanel);
    btnSandboxIcon.WhenAction = THISBACK(ShowSandboxPanel);
    btnLogsIcon.WhenAction = THISBACK(ShowLogsPanel);

    // Main actions
    btnStart.WhenAction = THISBACK(OnStartServer);
    btnStop.WhenAction = THISBACK(OnStopServer);

    // Tools panel actions (example - real connections depend on ArrayCtrl selections)
    // toolsAvailable.WhenLeftClick or WhenSel = ...
    // toolsEnabled.WhenLeftClick or WhenSel = ...
    // For simplicity, let's assume buttons to move all/selected:
    // Button(">>").WhenAction = THISBACK(ToolEnableAction);
    // Button("<<").WhenAction = THISBACK(ToolDisableAction);
    // These buttons are not in the layout, so this needs more thought for actual tool moving.
    // For now, tool list management might be manual or through context menus on ArrayCtrl.

    // Sandbox panel actions
    btnAddRoot.WhenAction = THISBACK(AddSandboxRootAction);
    btnRemoveRoot.WhenAction = THISBACK(RemoveSandboxRootAction);

    // Logs panel actions
    btnClearLogs.WhenAction = THISBACK(ClearLogsAction);
    // maxLogSizeEdit.WhenEnter = ... or WhenChange = ... to update config

    // Initial state
    SetEditingState(true); // Server is initially stopped, so UI is editable
    MainStack.Set(0);      // Default to ToolsPanel
    UpdateStatusDisplay();

    lblInstallPath = "Install: " + GetExeFolder(); // From TitleBar
    // lblInstallPathConfig from ConfigPanel should also be set if used.
    // It was named lblInstallPathConfig in the layout.
    // Ensure the member name matches if generated by With... template or access it by FindCtrl.
    // If using WithMcpServerWindowLayout, member name will be lblInstallPathConfig.
    // If that control is named 'lblInstallPathConfig' in the .layout file:
    this->lblInstallPathConfig = "Install Path: " + GetExeFolder();


    // Populate lists that depend on McpServer's initial state (if any beyond config)
    RefreshToolLists(); // Based on all registered tools vs enabled in config
}

// --- Action Handlers & UI Logic ---
void McpServerWindow::OnStartServer() {
    SyncUIToConfig(); // Get latest values from UI into current_config_ref

    String configFilePath = GetExeFolder() + "/config/config.json"; // Path to config file
    ConfigManager::Save(configFilePath, current_config_ref);
    server_ref.GetServer().AppendLog("Configuration saved to " + configFilePath);


    // Apply configuration to the server instance
    server_ref.SetPort(current_config_ref.serverPort);
    server_ref.ConfigureBind(current_config_ref.bindAllInterfaces);
    server_ref.GetPermissions() = current_config_ref.permissions;

    server_ref.GetSandboxRoots().Clear(); // Clear existing before adding from config
    for(const String& root : current_config_ref.sandboxRoots) {
        server_ref.AddSandboxRoot(root);
    }

    // Enable tools on the server based on the config
    // First, disable all tools that might be currently enabled on server instance
    for(const String& toolName : server_ref.GetAllToolNames()) {
        server_ref.DisableTool(toolName);
    }
    // Then, enable tools specified in the current configuration
    for(const String& toolName : current_config_ref.enabledTools) {
        if(server_ref.GetAllToolNames().Find(toolName) >=0) { // Check if tool is registered
             server_ref.EnableTool(toolName);
        } else {
            server_ref.GetServer().AppendLog("Warning: Tool '" + toolName + "' from config is not registered.");
        }
    }

    // Show Splash Screen
    McpSplash splash(*this, server_ref, current_config_ref); // Pass necessary references/data
    splash.Run(true); // Run as modal dialog

    if (server_ref.StartServer()) {
        SetEditingState(false); // Disable UI editing
    } else {
        Exclamation("Failed to start MCP server. Check logs for details.");
    }
    UpdateStatusDisplay();
}

void McpServerWindow::OnStopServer() {
    server_ref.StopServer();
    SetEditingState(true); // Enable UI editing
    UpdateStatusDisplay();
}

void McpServerWindow::SetEditingState(bool enabled) {
    // Example: Disable/Enable all configuration related controls
    // Tools Panel
    // toolsAvailable.Enable(enabled); // Interaction with tool lists
    // toolsEnabled.Enable(enabled);   // (Actual buttons for moving tools would be disabled/enabled)
    btnStart.Enable(enabled);
    btnStop.Enable(!enabled);

    // Config Panel
    portEdit.Enable(enabled);
    bindList.Enable(enabled);

    // Permissions Panel (all checkboxes)
    // Example: chkRead.Enable(enabled); ... for all permission checkboxes
    Ctrl* p = PermsPanel.GetFirstChild(); // Iterate over children of PermsPanel
    while(p) {
        p->Enable(enabled);
        p = p->GetNext();
    }

    // Sandbox Panel
    // sandboxRootsList.Enable(enabled); // For selections
    btnAddRoot.Enable(enabled);
    btnRemoveRoot.Enable(enabled);

    // Logs Panel
    maxLogSizeEdit.Enable(enabled);
    // btnClearLogs is always enabled, logConsole is always readonly (for viewing)
}

void McpServerWindow::AppendLog(const String& line) {
    logConsole.Insert(logConsole.GetLength(), GetSysTime().ToString() + " " + line + "\n");
    logConsole.Scrolly(logConsole.GetLineCount() * Draw::GetStdFontCy()); // Scroll to end
    if (logConsole.GetLineCount() > 2000) { // Basic trimming
        logConsole.Remove(0, logConsole.GetLineCount() - 1000);
    }
}

// --- Sidebar Navigation ---
void McpServerWindow::MenuAction() { /* Toggle sidebar width or show context menu */ }
void McpServerWindow::ShowToolsPanel()    { MainStack.Set(ToolsPanel); }
void McpServerWindow::ShowConfigPanel()   { MainStack.Set(ConfigPanel); }
void McpServerWindow::ShowPermsPanel()    { MainStack.Set(PermsPanel); }
void McpServerWindow::ShowSandboxPanel()  { MainStack.Set(SandboxPanel); }
void McpServerWindow::ShowLogsPanel()     { MainStack.Set(LogsPanel); }

// --- Other Actions ---
void McpServerWindow::AddSandboxRootAction() {
    String newRoot;
    if (EditText(newRoot, "Add Sandbox Root", "Enter directory path:")) {
        if (!newRoot.IsEmpty() && DirectoryExists(newRoot)) { // Basic validation
            // current_config_ref.sandboxRoots.Add(newRoot); // Add to config
            // RefreshSandboxList(); // Update UI
            // No, this should update the list in the UI (ArrayCtrl) directly
            // and then SyncUIToConfig will pick it up before starting server.
            // Or, if server is running, this action might be disabled or update server directly (complex).
            // For now, assume UI updates, then config sync on start.
            sandboxRootsList.Add(NormalizePath(newRoot));
        } else {
            Exclamation("Invalid path or directory does not exist.");
        }
    }
}
void McpServerWindow::RemoveSandboxRootAction() {
    int ix = sandboxRootsList.GetCursor();
    if (ix >= 0) {
        sandboxRootsList.Remove(ix);
    }
}
void McpServerWindow::ClearLogsAction() {
    logConsole.Clear();
    server_ref.GetServer().AppendLog("Log display cleared by user."); // Log this action itself
}

// --- Data Synchronization & UI Refresh ---
void McpServerWindow::SyncConfigToUI() {
    // Load data from current_config_ref into UI elements
    portEdit <<= current_config_ref.serverPort;
    bindList.SetIndex(current_config_ref.bindAllInterfaces ? 1 : 0); // 0: 127.0.0.1, 1: 0.0.0.0
    maxLogSizeEdit <<= current_config_ref.maxLogSizeMB;

    // Permissions
    chkRead.Set(current_config_ref.permissions.allowReadFiles);
    chkWrite.Set(current_config_ref.permissions.allowWriteFiles);
    // ... set all other permission checkboxes ...
    chkDelete.Set(current_config_ref.permissions.allowDeleteFiles);
    chkRename.Set(current_config_ref.permissions.allowRenameFiles);
    chkCreateDir.Set(current_config_ref.permissions.allowCreateDirs);
    chkSearch.Set(current_config_ref.permissions.allowSearchDirs);
    chkExec.Set(current_config_ref.permissions.allowExec);
    chkNetwork.Set(current_config_ref.permissions.allowNetworkAccess);
    chkExternal.Set(current_config_ref.permissions.allowExternalStorage);
    chkAttr.Set(current_config_ref.permissions.allowChangeAttributes);
    chkIPC.Set(current_config_ref.permissions.allowIPC);

    // Sandbox Roots
    sandboxRootsList.Clear();
    for(const String& root : current_config_ref.sandboxRoots) {
        sandboxRootsList.Add(root);
    }

    // Enabled Tools (this is more complex, needs to interact with McpServer's list of all tools)
    RefreshToolLists();
}

void McpServerWindow::SyncUIToConfig() {
    // Save data from UI elements back into current_config_ref
    current_config_ref.serverPort = portEdit.GetData();
    current_config_ref.bindAllInterfaces = bindList.GetIndex() == 1;
    current_config_ref.maxLogSizeMB = maxLogSizeEdit.GetData();

    // Permissions
    current_config_ref.permissions.allowReadFiles = chkRead.Get();
    current_config_ref.permissions.allowWriteFiles = chkWrite.Get();
    // ... get all other permission checkboxes ...
    current_config_ref.permissions.allowDeleteFiles = chkDelete.Get();
    current_config_ref.permissions.allowRenameFiles = chkRename.Get();
    current_config_ref.permissions.allowCreateDirs = chkCreateDir.Get();
    current_config_ref.permissions.allowSearchDirs = chkSearch.Get();
    current_config_ref.permissions.allowExec = chkExec.Get();
    current_config_ref.permissions.allowNetworkAccess = chkNetwork.Get();
    current_config_ref.permissions.allowExternalStorage = chkExternal.Get();
    current_config_ref.permissions.allowChangeAttributes = chkAttr.Get();
    current_config_ref.permissions.allowIPC = chkIPC.Get();

    // Sandbox Roots
    current_config_ref.sandboxRoots.Clear();
    for (int i = 0; i < sandboxRootsList.GetCount(); ++i) {
        current_config_ref.sandboxRoots.Add(sandboxRootsList.Get(i, 0).ToString()); // Assuming path is in column 0
    }

    // Enabled Tools
    current_config_ref.enabledTools.Clear();
    for (int i = 0; i < toolsEnabled.GetCount(); ++i) {
        current_config_ref.enabledTools.Add(toolsEnabled.Get(i, 0).ToString()); // Assuming name is in column 0
    }
}

void McpServerWindow::RefreshToolLists() {
    toolsAvailable.Clear();
    toolsEnabled.Clear();

    Vector<String> allServerTools = server_ref.GetAllToolNames(); // Tools registered with the server
    // Vector<String>& configuredEnabledTools = current_config_ref.enabledTools; // Tools marked as enabled in config

    for(const String& toolName : allServerTools) {
        // Check if this tool is in the config's enabled list AND actually enabled on server
        bool isEffectivelyEnabled = current_config_ref.enabledTools.Find(toolName) >=0 && server_ref.IsToolEnabled(toolName);

        // For UI consistency, often the config is the source of truth for the "enabled" list display
        // And on "Start Server", this config list is applied to the server.
        // Let's assume current_config_ref.enabledTools is the source for toolsEnabled list.

        if (current_config_ref.enabledTools.Find(toolName) >= 0) {
            toolsEnabled.Add(toolName);
        } else {
            toolsAvailable.Add(toolName);
        }
    }
    // TODO: Add buttons or DblClick actions to move items between toolsAvailable and toolsEnabled
    // and update current_config_ref.enabledTools accordingly.
}

void McpServerWindow::RefreshSandboxList() {
    sandboxRootsList.Clear();
    for(const String& root : current_config_ref.sandboxRoots) { // Assuming config is source of truth
        sandboxRootsList.Add(root);
    }
}

void McpServerWindow::RefreshPermissionCheckboxes() {
    // This is mostly covered by SyncConfigToUI
    // Call this if individual permission changes outside of full SyncConfigToUI
}
void McpServerWindow::RefreshLogConfig() {
    maxLogSizeEdit <<= current_config_ref.maxLogSizeMB;
}

void McpServerWindow::UpdateStatusDisplay() {
    if (server_ref.IsListening()) {
        lblStatus = "Status: Running on " + server_ref.GetListenHost() + ":" + AsString(server_ref.GetPort());
    } else {
        lblStatus = "Status: Stopped";
    }
}

// Placeholder for ToolEnableAction / ToolDisableAction
void McpServerWindow::ToolEnableAction() {
    // Example: Move selected from toolsAvailable to toolsEnabled
    int cursor = toolsAvailable.GetCursor();
    if(cursor >= 0) {
        String toolName = toolsAvailable.Get(cursor, 0).ToString();
        toolsEnabled.Add(toolName);
        toolsAvailable.Remove(cursor);
        // current_config_ref.enabledTools.Add(toolName); // Update config directly or via SyncUIToConfig
    }
}
void McpServerWindow::ToolDisableAction() {
    // Example: Move selected from toolsEnabled to toolsAvailable
    int cursor = toolsEnabled.GetCursor();
    if(cursor >= 0) {
        String toolName = toolsEnabled.Get(cursor, 0).ToString();
        toolsAvailable.Add(toolName);
        toolsEnabled.Remove(cursor);
        // current_config_ref.enabledTools.RemoveKey(toolName); // Update config
    }
}
